{
  "version": 3,
  "sources": ["../../../../node_modules/@dnd-kit/utilities/src/hooks/useCombinedRefs.ts", "../../../../node_modules/@dnd-kit/utilities/src/execution-context/canUseDOM.ts", "../../../../node_modules/@dnd-kit/utilities/src/type-guards/isWindow.ts", "../../../../node_modules/@dnd-kit/utilities/src/type-guards/isNode.ts", "../../../../node_modules/@dnd-kit/utilities/src/execution-context/getWindow.ts", "../../../../node_modules/@dnd-kit/utilities/src/type-guards/isDocument.ts", "../../../../node_modules/@dnd-kit/utilities/src/type-guards/isHTMLElement.ts", "../../../../node_modules/@dnd-kit/utilities/src/type-guards/isSVGElement.ts", "../../../../node_modules/@dnd-kit/utilities/src/execution-context/getOwnerDocument.ts", "../../../../node_modules/@dnd-kit/utilities/src/hooks/useIsomorphicLayoutEffect.ts", "../../../../node_modules/@dnd-kit/utilities/src/hooks/useEvent.ts", "../../../../node_modules/@dnd-kit/utilities/src/hooks/useInterval.ts", "../../../../node_modules/@dnd-kit/utilities/src/hooks/useLatestValue.ts", "../../../../node_modules/@dnd-kit/utilities/src/hooks/useLazyMemo.ts", "../../../../node_modules/@dnd-kit/utilities/src/hooks/useNodeRef.ts", "../../../../node_modules/@dnd-kit/utilities/src/hooks/usePrevious.ts", "../../../../node_modules/@dnd-kit/utilities/src/hooks/useUniqueId.ts", "../../../../node_modules/@dnd-kit/utilities/src/adjustment.ts", "../../../../node_modules/@dnd-kit/utilities/src/event/hasViewportRelativeCoordinates.ts", "../../../../node_modules/@dnd-kit/utilities/src/event/isKeyboardEvent.ts", "../../../../node_modules/@dnd-kit/utilities/src/event/isTouchEvent.ts", "../../../../node_modules/@dnd-kit/utilities/src/coordinates/getEventCoordinates.ts", "../../../../node_modules/@dnd-kit/utilities/src/css.ts", "../../../../node_modules/@dnd-kit/utilities/src/focus/findFirstFocusableNode.ts", "../../../../node_modules/@dnd-kit/modifiers/src/createSnapModifier.ts", "../../../../node_modules/@dnd-kit/modifiers/src/restrictToHorizontalAxis.ts", "../../../../node_modules/@dnd-kit/modifiers/src/utilities/restrictToBoundingRect.ts", "../../../../node_modules/@dnd-kit/modifiers/src/restrictToParentElement.ts", "../../../../node_modules/@dnd-kit/modifiers/src/restrictToFirstScrollableAncestor.ts", "../../../../node_modules/@dnd-kit/modifiers/src/restrictToVerticalAxis.ts", "../../../../node_modules/@dnd-kit/modifiers/src/restrictToWindowEdges.ts", "../../../../node_modules/@dnd-kit/modifiers/src/snapCenterToCursor.ts"],
  "sourcesContent": ["import {useMemo} from 'react';\n\nexport function useCombinedRefs<T>(\n  ...refs: ((node: T) => void)[]\n): (node: T) => void {\n  return useMemo(\n    () => (node: T) => {\n      refs.forEach((ref) => ref(node));\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    refs\n  );\n}\n", "// https://github.com/facebook/react/blob/master/packages/shared/ExecutionEnvironment.js\nexport const canUseDOM =\n  typeof window !== 'undefined' &&\n  typeof window.document !== 'undefined' &&\n  typeof window.document.createElement !== 'undefined';\n", "export function isWindow(element: Object): element is typeof window {\n  const elementString = Object.prototype.toString.call(element);\n  return (\n    elementString === '[object Window]' ||\n    // In Electron context the Window object serializes to [object global]\n    elementString === '[object global]'\n  );\n}\n", "export function isNode(node: Object): node is Node {\n  return 'nodeType' in node;\n}\n", "import {isWindow} from '../type-guards/isWindow';\nimport {isNode} from '../type-guards/isNode';\n\nexport function getWindow(target: Event['target']): typeof window {\n  if (!target) {\n    return window;\n  }\n\n  if (isWindow(target)) {\n    return target;\n  }\n\n  if (!isNode(target)) {\n    return window;\n  }\n\n  return target.ownerDocument?.defaultView ?? window;\n}\n", "import {getWindow} from '../execution-context/getWindow';\n\nexport function isDocument(node: Node): node is Document {\n  const {Document} = getWindow(node);\n\n  return node instanceof Document;\n}\n", "import {getWindow} from '../execution-context/getWindow';\n\nimport {isWindow} from './isWindow';\n\nexport function isHTMLElement(node: Node | Window): node is HTMLElement {\n  if (isWindow(node)) {\n    return false;\n  }\n\n  return node instanceof getWindow(node).HTMLElement;\n}\n", "import {getWindow} from '../execution-context/getWindow';\n\nexport function isSVGElement(node: Node): node is SVGElement {\n  return node instanceof getWindow(node).SVGElement;\n}\n", "import {\n  isWindow,\n  isHTMLElement,\n  isDocument,\n  isNode,\n  isSVGElement,\n} from '../type-guards';\n\nexport function getOwnerDocument(target: Event['target']): Document {\n  if (!target) {\n    return document;\n  }\n\n  if (isWindow(target)) {\n    return target.document;\n  }\n\n  if (!isNode(target)) {\n    return document;\n  }\n\n  if (isDocument(target)) {\n    return target;\n  }\n\n  if (isHTMLElement(target) || isSVGElement(target)) {\n    return target.ownerDocument;\n  }\n\n  return document;\n}\n", "import {useEffect, useLayoutEffect} from 'react';\n\nimport {canUseDOM} from '../execution-context';\n\n/**\n * A hook that resolves to useEffect on the server and useLayoutEffect on the client\n * @param callback {function} Callback function that is invoked when the dependencies of the hook change\n */\nexport const useIsomorphicLayoutEffect = canUseDOM\n  ? useLayoutEffect\n  : useEffect;\n", "import {useCallback, useRef} from 'react';\n\nimport {useIsomorphicLayoutEffect} from './useIsomorphicLayoutEffect';\n\nexport function useEvent<T extends Function>(handler: T | undefined) {\n  const handlerRef = useRef<T | undefined>(handler);\n\n  useIsomorphicLayoutEffect(() => {\n    handlerRef.current = handler;\n  });\n\n  return useCallback(function (...args: any) {\n    return handlerRef.current?.(...args);\n  }, []);\n}\n", "import {useCallback, useRef} from 'react';\n\nexport function useInterval() {\n  const intervalRef = useRef<number | null>(null);\n\n  const set = useCallback((listener: Function, duration: number) => {\n    intervalRef.current = setInterval(listener, duration);\n  }, []);\n\n  const clear = useCallback(() => {\n    if (intervalRef.current !== null) {\n      clearInterval(intervalRef.current);\n      intervalRef.current = null;\n    }\n  }, []);\n\n  return [set, clear] as const;\n}\n", "import {useRef} from 'react';\nimport type {DependencyList} from 'react';\n\nimport {useIsomorphicLayoutEffect} from './useIsomorphicLayoutEffect';\n\nexport function useLatestValue<T extends any>(\n  value: T,\n  dependencies: DependencyList = [value]\n) {\n  const valueRef = useRef<T>(value);\n\n  useIsomorphicLayoutEffect(() => {\n    if (valueRef.current !== value) {\n      valueRef.current = value;\n    }\n  }, dependencies);\n\n  return valueRef;\n}\n", "import {useMemo, useRef} from 'react';\n\nexport function useLazyMemo<T>(\n  callback: (prevValue: T | undefined) => T,\n  dependencies: any[]\n) {\n  const valueRef = useRef<T>();\n\n  return useMemo(\n    () => {\n      const newValue = callback(valueRef.current);\n      valueRef.current = newValue;\n\n      return newValue;\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [...dependencies]\n  );\n}\n", "import {useRef, useCallback} from 'react';\n\nimport {useEvent} from './useEvent';\n\nexport function useNodeRef(\n  onChange?: (\n    newElement: HTMLElement | null,\n    previousElement: HTMLElement | null\n  ) => void\n) {\n  const onChangeHandler = useEvent(onChange);\n  const node = useRef<HTMLElement | null>(null);\n  const setNodeRef = useCallback(\n    (element: HTMLElement | null) => {\n      if (element !== node.current) {\n        onChangeHandler?.(element, node.current);\n      }\n\n      node.current = element;\n    },\n    //eslint-disable-next-line\n    []\n  );\n\n  return [node, setNodeRef] as const;\n}\n", "import {useRef, useEffect} from 'react';\n\nexport function usePrevious<T>(value: T) {\n  const ref = useRef<T>();\n\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n\n  return ref.current;\n}\n", "import {useMemo} from 'react';\n\nlet ids: Record<string, number> = {};\n\nexport function useUniqueId(prefix: string, value?: string) {\n  return useMemo(() => {\n    if (value) {\n      return value;\n    }\n\n    const id = ids[prefix] == null ? 0 : ids[prefix] + 1;\n    ids[prefix] = id;\n\n    return `${prefix}-${id}`;\n  }, [prefix, value]);\n}\n", "function createAdjustmentFn(modifier: number) {\n  return <T extends Record<U, number>, U extends string>(\n    object: T,\n    ...adjustments: Partial<T>[]\n  ): T => {\n    return adjustments.reduce<T>(\n      (accumulator, adjustment) => {\n        const entries = Object.entries(adjustment) as [U, number][];\n\n        for (const [key, valueAdjustment] of entries) {\n          const value = accumulator[key];\n\n          if (value != null) {\n            accumulator[key] = (value + modifier * valueAdjustment) as T[U];\n          }\n        }\n\n        return accumulator;\n      },\n      {\n        ...object,\n      }\n    );\n  };\n}\n\nexport const add = createAdjustmentFn(1);\nexport const subtract = createAdjustmentFn(-1);\n", "export function hasViewportRelativeCoordinates(\n  event: Event\n): event is Event & Pick<PointerEvent, 'clientX' | 'clientY'> {\n  return 'clientX' in event && 'clientY' in event;\n}\n", "import {getWindow} from '../execution-context';\n\nexport function isKeyboardEvent(\n  event: Event | undefined | null\n): event is KeyboardEvent {\n  if (!event) {\n    return false;\n  }\n\n  const {KeyboardEvent} = getWindow(event.target);\n\n  return KeyboardEvent && event instanceof KeyboardEvent;\n}\n", "import {getWindow} from '../execution-context';\n\nexport function isTouchEvent(\n  event: Event | undefined | null\n): event is TouchEvent {\n  if (!event) {\n    return false;\n  }\n\n  const {TouchEvent} = getWindow(event.target);\n\n  return TouchEvent && event instanceof TouchEvent;\n}\n", "import type {Coordinates} from './types';\nimport {isTouchEvent, hasViewportRelativeCoordinates} from '../event';\n\n/**\n * Returns the normalized x and y coordinates for mouse and touch events.\n */\nexport function getEventCoordinates(event: Event): Coordinates | null {\n  if (isTouchEvent(event)) {\n    if (event.touches && event.touches.length) {\n      const {clientX: x, clientY: y} = event.touches[0];\n\n      return {\n        x,\n        y,\n      };\n    } else if (event.changedTouches && event.changedTouches.length) {\n      const {clientX: x, clientY: y} = event.changedTouches[0];\n\n      return {\n        x,\n        y,\n      };\n    }\n  }\n\n  if (hasViewportRelativeCoordinates(event)) {\n    return {\n      x: event.clientX,\n      y: event.clientY,\n    };\n  }\n\n  return null;\n}\n", "export type Transform = {\n  x: number;\n  y: number;\n  scaleX: number;\n  scaleY: number;\n};\n\nexport interface Transition {\n  property: string;\n  easing: string;\n  duration: number;\n}\n\nexport const CSS = Object.freeze({\n  Translate: {\n    toString(transform: Transform | null) {\n      if (!transform) {\n        return;\n      }\n\n      const {x, y} = transform;\n\n      return `translate3d(${x ? Math.round(x) : 0}px, ${\n        y ? Math.round(y) : 0\n      }px, 0)`;\n    },\n  },\n  Scale: {\n    toString(transform: Transform | null) {\n      if (!transform) {\n        return;\n      }\n\n      const {scaleX, scaleY} = transform;\n\n      return `scaleX(${scaleX}) scaleY(${scaleY})`;\n    },\n  },\n  Transform: {\n    toString(transform: Transform | null) {\n      if (!transform) {\n        return;\n      }\n\n      return [\n        CSS.Translate.toString(transform),\n        CSS.Scale.toString(transform),\n      ].join(' ');\n    },\n  },\n  Transition: {\n    toString({property, duration, easing}: Transition) {\n      return `${property} ${duration}ms ${easing}`;\n    },\n  },\n});\n", "const SELECTOR =\n  'a,frame,iframe,input:not([type=hidden]):not(:disabled),select:not(:disabled),textarea:not(:disabled),button:not(:disabled),*[tabindex]';\n\nexport function findFirstFocusableNode(\n  element: HTMLElement\n): HTMLElement | null {\n  if (element.matches(SELECTOR)) {\n    return element;\n  }\n\n  return element.querySelector(SELECTOR);\n}\n", "import type {Modifier} from '@dnd-kit/core';\n\nexport function createSnapModifier(gridSize: number): Modifier {\n  return ({transform}) => ({\n    ...transform,\n    x: Math.ceil(transform.x / gridSize) * gridSize,\n    y: Math.ceil(transform.y / gridSize) * gridSize,\n  });\n}\n", "import type {Modifier} from '@dnd-kit/core';\n\nexport const restrictToHorizontalAxis: Modifier = ({transform}) => {\n  return {\n    ...transform,\n    y: 0,\n  };\n};\n", "import type {ClientRect} from '@dnd-kit/core';\nimport type {Transform} from '@dnd-kit/utilities';\n\nexport function restrictToBoundingRect(\n  transform: Transform,\n  rect: ClientRect,\n  boundingRect: ClientRect\n): Transform {\n  const value = {\n    ...transform,\n  };\n\n  if (rect.top + transform.y <= boundingRect.top) {\n    value.y = boundingRect.top - rect.top;\n  } else if (\n    rect.bottom + transform.y >=\n    boundingRect.top + boundingRect.height\n  ) {\n    value.y = boundingRect.top + boundingRect.height - rect.bottom;\n  }\n\n  if (rect.left + transform.x <= boundingRect.left) {\n    value.x = boundingRect.left - rect.left;\n  } else if (\n    rect.right + transform.x >=\n    boundingRect.left + boundingRect.width\n  ) {\n    value.x = boundingRect.left + boundingRect.width - rect.right;\n  }\n\n  return value;\n}\n", "import type {Modifier} from '@dnd-kit/core';\nimport {restrictToBoundingRect} from './utilities';\n\nexport const restrictToParentElement: Modifier = ({\n  containerNodeRect,\n  draggingNodeRect,\n  transform,\n}) => {\n  if (!draggingNodeRect || !containerNodeRect) {\n    return transform;\n  }\n\n  return restrictToBoundingRect(transform, draggingNodeRect, containerNodeRect);\n};\n", "import type {Modifier} from '@dnd-kit/core';\nimport {restrictToBoundingRect} from './utilities';\n\nexport const restrictToFirstScrollableAncestor: Modifier = ({\n  draggingNodeRect,\n  transform,\n  scrollableAncestorRects,\n}) => {\n  const firstScrollableAncestorRect = scrollableAncestorRects[0];\n\n  if (!draggingNodeRect || !firstScrollableAncestorRect) {\n    return transform;\n  }\n\n  return restrictToBoundingRect(\n    transform,\n    draggingNodeRect,\n    firstScrollableAncestorRect\n  );\n};\n", "import type {Modifier} from '@dnd-kit/core';\n\nexport const restrictToVerticalAxis: Modifier = ({transform}) => {\n  return {\n    ...transform,\n    x: 0,\n  };\n};\n", "import type {Modifier} from '@dnd-kit/core';\n\nimport {restrictToBoundingRect} from './utilities';\n\nexport const restrictToWindowEdges: Modifier = ({\n  transform,\n  draggingNodeRect,\n  windowRect,\n}) => {\n  if (!draggingNodeRect || !windowRect) {\n    return transform;\n  }\n\n  return restrictToBoundingRect(transform, draggingNodeRect, windowRect);\n};\n", "import type {Modifier} from '@dnd-kit/core';\nimport {getEventCoordinates} from '@dnd-kit/utilities';\n\nexport const snapCenterToCursor: Modifier = ({\n  activatorEvent,\n  draggingNodeRect,\n  transform,\n}) => {\n  if (draggingNodeRect && activatorEvent) {\n    const activatorCoordinates = getEventCoordinates(activatorEvent);\n\n    if (!activatorCoordinates) {\n      return transform;\n    }\n\n    const offsetX = activatorCoordinates.x - draggingNodeRect.left;\n    const offsetY = activatorCoordinates.y - draggingNodeRect.top;\n\n    return {\n      ...transform,\n      x: transform.x + offsetX - draggingNodeRect.width / 2,\n      y: transform.y + offsetY - draggingNodeRect.height / 2,\n    };\n  }\n\n  return transform;\n};\n"],
  "mappings": "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",
  "names": ["canUseDOM", "window", "document", "createElement", "isWindow", "element", "elementString", "Object", "prototype", "toString", "call", "isNode", "node", "getWindow", "target", "ownerDocument", "defaultView", "createAdjustmentFn", "modifier", "object", "adjustments", "reduce", "accumulator", "adjustment", "entries", "Object", "key", "valueAdjustment", "value", "add", "subtract", "hasViewportRelativeCoordinates", "event", "isTouchEvent", "event", "TouchEvent", "getWindow", "target", "getEventCoordinates", "touches", "length", "clientX", "x", "clientY", "y", "changedTouches", "hasViewportRelativeCoordinates", "CSS", "Object", "freeze", "Translate", "toString", "transform", "Math", "round", "Scale", "scaleX", "scaleY", "Transform", "join", "Transition", "property", "duration", "easing", "createSnapModifier", "gridSize", "transform", "x", "Math", "ceil", "y", "restrictToHorizontalAxis", "restrictToBoundingRect", "rect", "boundingRect", "value", "top", "bottom", "height", "left", "right", "width", "restrictToParentElement", "containerNodeRect", "draggingNodeRect", "restrictToFirstScrollableAncestor", "scrollableAncestorRects", "firstScrollableAncestorRect", "restrictToVerticalAxis", "restrictToWindowEdges", "windowRect", "snapCenterToCursor", "activatorEvent", "activatorCoordinates", "getEventCoordinates", "offsetX", "offsetY"]
}
